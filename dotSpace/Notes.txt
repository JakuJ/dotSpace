
Hvordan forventer han at PULL virker? Det er jo polling. men det skal uddybes.
	- Hvilken besked sendes til servernoden, efter en request? altså en request for response?
	- Hvor ofte polles der, eller hvem står for det? (Brugeren eller klient noden)
	Konklusion: Denne connectionmode virker ikke udpræget brugbar.

Hvad med porte? Man kan ikke have en klient som listener to gange på den samme lokale ip adresse på samme port. Dette skal angives i source så?
	- Givet en situation hvor to agenter connecter via hver deres clientNode til en servernode. De to client nodes er på samme pc, servernode er på en fjern pc. 
      Hvis de begge anvender Push connection scheme, så vil de begge forsøge at lytte på den samme port hvilket forårsager et crash.
      Hvis man satte en central listener op, som venter på connections globalt i processen, når der så kommer indgående connections, skal beskederne så uddelegeres til de respektive agenter.
	  Dette alternativ vil kun virker hvis de to agenter køres i den samme process. Det vil derfor ikke virker med to agenter i hver deres process.

	- Givet en situation hvor en agent connecter via en clientnode til en servernode. De er begge på den samme pc. De kan IKKE anvende push connectionscheme fordi de begge ikke kan lytte på den samme port. 
	  En central listener vil være problematisk da beskeder ikke kan uddelegeres på baggrund af sessionid, og den vil alligevel kun virker hvis client og server kører i samme process. Det vil de i de fleste tilfælde ikke gøre.

	Konklusion: Der skal lyttes på en anden port HVER gang. Det kan ikke engang være statisk. Der skal sættes en port range op til klienten, hvor de individuelle porte recycles. Porten som anvendes skal sendes med til servernoden.

JSon er problematisk fordi der ikke er typeinferencing. 
	- Det betyder at patterns kan være et problem: <typeof(string), "milk", typeof(int)> hvis det skal bruges på tværs af sprog. Java til .NET til python
		Dette kan løses vha. <null, "milk", null>.
	
	- Deserialisering er problematisk fordi, den ved ikke på forhånd hvilken typer som anvendes i tuples og patterns. Det virker fint KUN med primitive typer, men ikke med komplekse objekter.

	- Beskeder skal deserialiseres to gange. a) En gang til at afgøre hvilken besked type der anvendes (MessageBase), og b) en gang til at deserialisere til den faktiske type. 
		Dette er ikke robust, fordi hvis beskeden er af en type, men angiver en forkert vil b) fejle.
 
	Konklusion: Hvis man kan acceptere at der kun benyttes primitive typer, er JSon fint nok. JSon kan ikke håndtere komplekse typer og referencer slet ikke muligt. 
	            Uden referencer vil komplekse objekter som anvender referencer lede til redundant data, og objektet SKAL efterbehandles. Alternativt skal XML anvendes.